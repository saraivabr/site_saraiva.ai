import type { Env, GeneratedArticle } from './types';

const GITHUB_API = 'https://api.github.com';

interface GitHubTreeItem {
  path: string;
  mode: '100644';
  type: 'blob';
  sha: string;
}

export async function commitArticle(
  article: GeneratedArticle,
  imageData: ArrayBuffer | null,
  env: Env
): Promise<boolean> {
  try {
    const repo = env.GITHUB_REPO;
    const headers = {
      'Authorization': `Bearer ${env.GITHUB_TOKEN}`,
      'Accept': 'application/vnd.github.v3+json',
      'User-Agent': 'SaraivaAI-ContentBot/1.0',
    };

    // 1. Get the latest commit SHA on main
    const refRes = await fetch(`${GITHUB_API}/repos/${repo}/git/ref/heads/main`, { headers });
    if (!refRes.ok) throw new Error(`Failed to get ref: ${refRes.status}`);
    const refData = await refRes.json() as { object: { sha: string } };
    const baseSha = refData.object.sha;

    // 2. Get the tree of the latest commit
    const commitRes = await fetch(`${GITHUB_API}/repos/${repo}/git/commits/${baseSha}`, { headers });
    if (!commitRes.ok) throw new Error(`Failed to get commit: ${commitRes.status}`);
    const commitData = await commitRes.json() as { tree: { sha: string } };
    const baseTreeSha = commitData.tree.sha;

    // 3. Create blobs for the article and optional image
    const markdownContent = buildMarkdownFile(article);
    const mdBlobSha = await createBlob(repo, markdownContent, 'utf-8', headers);

    const treeItems: GitHubTreeItem[] = [
      {
        path: `src/content/${article.category}/${article.slug}.md`,
        mode: '100644',
        type: 'blob',
        sha: mdBlobSha,
      },
    ];

    if (imageData) {
      const base64Image = arrayBufferToBase64(imageData);
      const imgBlobSha = await createBlob(repo, base64Image, 'base64', headers);
      treeItems.push({
        path: `public/images/content/${article.slug}.webp`,
        mode: '100644',
        type: 'blob',
        sha: imgBlobSha,
      });
    }

    // 4. Create a new tree
    const treeRes = await fetch(`${GITHUB_API}/repos/${repo}/git/trees`, {
      method: 'POST',
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({ base_tree: baseTreeSha, tree: treeItems }),
    });
    if (!treeRes.ok) throw new Error(`Failed to create tree: ${treeRes.status}`);
    const treeData = await treeRes.json() as { sha: string };

    // 5. Create a new commit
    const newCommitRes = await fetch(`${GITHUB_API}/repos/${repo}/git/commits`, {
      method: 'POST',
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        message: `content: add ${article.category}/${article.slug}\n\nAuto-generated by Saraiva.AI Content Bot`,
        tree: treeData.sha,
        parents: [baseSha],
      }),
    });
    if (!newCommitRes.ok) throw new Error(`Failed to create commit: ${newCommitRes.status}`);
    const newCommitData = await newCommitRes.json() as { sha: string };

    // 6. Update the reference
    const updateRefRes = await fetch(`${GITHUB_API}/repos/${repo}/git/refs/heads/main`, {
      method: 'PATCH',
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({ sha: newCommitData.sha }),
    });
    if (!updateRefRes.ok) throw new Error(`Failed to update ref: ${updateRefRes.status}`);

    console.log(`Committed: ${article.category}/${article.slug}`);
    return true;
  } catch (err) {
    console.error('GitHub commit failed:', err);
    return false;
  }
}

async function createBlob(
  repo: string,
  content: string,
  encoding: 'utf-8' | 'base64',
  headers: Record<string, string>
): Promise<string> {
  const res = await fetch(`${GITHUB_API}/repos/${repo}/git/blobs`, {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify({ content, encoding }),
  });
  if (!res.ok) throw new Error(`Failed to create blob: ${res.status}`);
  const data = await res.json() as { sha: string };
  return data.sha;
}

function buildMarkdownFile(article: GeneratedArticle): string {
  const frontmatter: Record<string, unknown> = {
    title: article.title,
    slug: article.slug,
    category: article.category,
    date: new Date().toISOString().split('T')[0],
    author: 'Saraiva',
    description: article.description,
    tags: article.tags,
    image: `/images/content/${article.slug}.webp`,
    source: article.sourceUrl,
    featured: false,
  };

  if (article.difficulty) frontmatter.difficulty = article.difficulty;
  if (article.rating) frontmatter.rating = article.rating;
  if (article.pricing) frontmatter.pricing = article.pricing;

  const yamlLines = Object.entries(frontmatter).map(([key, value]) => {
    if (typeof value === 'string') return `${key}: "${value}"`;
    if (Array.isArray(value)) return `${key}: ${JSON.stringify(value)}`;
    return `${key}: ${value}`;
  });

  return `---\n${yamlLines.join('\n')}\n---\n\n${article.content}`;
}

function arrayBufferToBase64(buffer: ArrayBuffer): string {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
